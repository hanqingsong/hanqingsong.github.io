---
title: jvm内存模型
date: 2018-10-20 10:08:42
categories:
    - JVM
tags:
    - JVM
---
## 程序计数器
程序计数器是一块很小的内存区域，可以看作是当前线程所执行字节码的行号指示器。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个指示器完成。
由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定时刻，一个处理器只会执行一个线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这块内存区域为“线程私有”内存。
如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（null）。
此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

## 虚拟机栈
线程私有，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行内存模型：每个方法被执行的时候都会创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等。

### 局部变量表
局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译称Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。
局部变量表的容量以变量槽（slot）为最小单位，32位虚拟机中一个slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）。
虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问。
系统不会位局部变量赋予初始值。

### 操作数栈
和局部变量区一样，操作数栈也是被组织成一个以字节长为单位的数组。但是和前者不同的是，它不是通过索引访问的，而是通过标准的栈操作--压栈和出栈--来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。
虚拟机把操作数栈作为它的工作区--大多数指令都要从这里弹出数据，执行计算，然后把结果压回操作数栈。

### 动态连接
虚拟机在运行的时候，运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用。如果代表栈帧A的方法想要调用代表栈帧B的方法，那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数，但是因为符号引用并不是直接指向代表B方法的内存位置，所以在调用之前还必须把符号引用转换为直接引用，然后通过直接引用才可以访问到真正的方法。

如果符号引用是在类加载阶段或者第一次使用的时候转换为直接引用，那么这种转换为静态解析，如果是在运行期间转换为直接引用，那么这种转换就称为动态连接。

### 返回地址
方法的返回分为两种，一种是正常退出，退出后会根据方法的定义来决定是否要传返回值给上层调用者，一种是异常导致的方法结束，这种情况不会传返回值给上层调用者。
无论哪种方式对方法结束，在退出方法时都会跳转到当前方法被调用的位置，如果方法正常退出的，则调用者的PC计数器的值可以作为返回地址，如果是异常退出的，则是需要通过异常处理表来确定。

方法的一次调用就对应着栈帧在虚拟机栈中的一次入栈和出栈操作，因此退出时可能做的事情包括：恢复上层方法的局部变量表以及操作数栈，如果有返回值的话，就会把返回值压入到调用者的栈帧的操作数栈中，还会把PC计数器的值调整为方法调用入口的下一条指令。

## 本地方法栈
本地方法栈和虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到到Native方法服务。

## 堆
堆是Java虚拟机所管理的内存中最大的一块。Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

堆是垃圾收集器管理的主要区域。如果从内存回收角度看，由于现在收集器基本都采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代。

## 方法区
方法区在一个jvm实例的内部，类型信息被存储在一个成为方法区的内存逻辑中。类型信息是由类加载器在类加载时从类文件中提取出来的。类（静态）变量也存储在方法区中。
