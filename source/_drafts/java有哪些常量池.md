---
title: java有哪些常量池
date: 2018-11-01 17:24:08
categories:
    - jvm
tags:
    - jvm
    - java
---
###  java有哪些常量池
Class文件中的常量池
运行时常量池
全局字符串常量池

### Class文件中的常量池
这里面主要存放两大类常量：      
字面量(Literal)：文本字符串等  
符号引用(Symbolic References)：属于编译原理方面的概念，包含三类常量：       类和接口的全限定名(Full Qualified Name)      
字段的名称和描述符(Descriptor)       
方法的名称和描述符

这个用javap看一下就能明白，这里只涉及字符串就不谈其他的了。简单地说，用双引号引起来的字符串字面量都会进这里面。

### 运行时常量池
方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池(Constant Pool Table)，存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。

### 全局字符串常量池
HotSpot VM里，记录interned string的一个全局表叫做StringTable，它本质上就是个HashSet<String>。这是个纯运行时的结构，而且是惰性（lazy）维护的。注意它只存储对java.lang.String实例的引用，而不存储String对象的内容。 注意，它只存了引用，根据这个引用可以得到具体的String对象。一般我们说一个字符串进入了全局的字符串常量池其实是说在这个StringTable中保存了对它的引用，反之，如果说没有在其中就是说StringTable中没有对它的引用。

### 字面量进入字符串常量池的时机
```
在类加载阶段， JVM会在堆中创建 对应这些 class文件常量池中的 字符串对象实例 并在字符串常量池中驻留其引用。具体在resolve阶段执行。这些常量全局共享。
```
这里说的比较笼统，没错，是resolve阶段，但是并不是大家想的那样，立即就创建对象并且在字符串常量池中驻留了引用。 JVM规范里明确指定resolve阶段可以是lazy的。
就HotSpot VM的实现来说，加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池（即在StringTable中并没有相应的引用，在堆中也没有对应的对象产生）

### 总结
JVM规范里明确指定resolve阶段是lazy的
加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池
在第一次引用该项的ldc指令被第一次执行到的时候才会resolve
static修饰的变量，在类加载阶段中的初始化阶段，会为静态变量指定初始值

## 资料
木女孩 https://www.zhihu.com/question/55994121/answer/147296098