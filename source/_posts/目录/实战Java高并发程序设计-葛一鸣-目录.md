---
title: 实战Java高并发程序设计-葛一鸣-目录
date: 2019-01-06 08:02:45
categories:
    - 目录
tags:
---

```
第1章走入并行世界 
    1.1何去何从的并行计算 
        1.1.1忘掉那该死的并行 
        1.1.2可怕的现实：摩尔定律的失效 
        1.1.3柳暗花明：不断地前进 
        1.1.4光明或是黑暗 
    1.2你必须知道的几个概念 
        1.2.1同步（Synchronous）和异步（Asynchronous） 
        1.2.2并发（Concurrency）和并行（Parallelism） 
        1.2.3临界区 
        1.2.4阻塞（Blocking）和非阻塞（Non—Blocking） 
        1.2.5死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock） 
    1.3并发级别 
        1.3.1阻塞（Blocking） 
        1.3.2无饥饿（Starvation—Free） 
        1.3.3无障碍（Obstruction—Free） 
        1.3.4无锁（Lock—Free） 
        1.3.5无等待（Wait—Free） 
    1.4有关并行的两个重要定律 
        1.4.1Amdahl定律 
        1.4.2Gustafson定律 
        1.4.3Amdahl定律和Gustafson定律是否相互矛盾 
    1.5回到Java：JMM 
        1.5.1原子性（Atomicity） 
        1.5.2可见性（Visibility） 
        1.5.3有序性（Ordering） 
        1.5.4哪些指令不能重排：Happen—Before规则 
    1.6参考文献 
第2章Java并行程序基础 
    2.1有关线程你必须知道的事 
    2.2初始线程：线程的基本操作 
        2.2.1新建线程 
        2.2.2终止线程 
        2.2.3线程中断 
        2.2.4等待（wait）和通知（notify） 
        2.2.5挂起（suspend）和继续执行（resume）线程 
        2.2.6等待线程结束（join）和谦让（yield） 
    2.3volatile与Java内存模型（JMM） 
    2.4分门别类的管理：线程组 
    2.5驻守后台：守护线程（Daemon） 
    2.6先干重要的事：线程优先级 
    2.7线程安全的概念与synchronized 
    2.8程序中的幽灵：隐蔽的错误 
        2.8.1无提示的错误案例 
        2.8.2并发下的ArrayList 
        2.8.3并发下诡异的HashMap 
        2.8.4初学者常见问题：错误的加锁 
    2.9参考文献 
第3章JDK并发包 
    3.1多线程的团队协作：同步控制 
        3.1.1synchronized的功能扩展：重入锁 
        3.1.2重入锁的好搭档：Condition条件 
        3.1.3允许多个线程同时访问：信号量（Semaphore） 
        3.1.4ReadWriteLock读写锁 
        3.1.5倒计时器：CountDownLatch 
        3.1.6循环栅栏：CyclicBarrier 
        3.1.7线程阻塞工具类：LockSupport 
    3.2线程复用：线程池 
        3.2.1什么是线程池 
        3.2.2不要重复发明轮子：JDK对线程池的支持 
        3.2.3刨根究底：核心线程池的内部实现 
        3.2.4超负载了怎么办：拒绝策略 
        3.2.5自定义线程创建：ThreadFactory 
        3.2.6我的应用我做主：扩展线程池 
        3.2.7合理的选择：优化线程池线程数量 
        3.2.8堆栈去哪里了：在线程池中寻找堆栈 
        3.2.9分而治之：Fork／Join框架 
    3.3不要重复发明轮子：JDK的并发容器 
        3.3.1超好用的工具类：并发集合简介 
        3.3.2线程安全的HashMap 
        3.3.3有关List的线程安全 
        3.3.4高效读写的队列：深度剖析ConcurrentLinkedQueue 
        3.3.5高效读取：不变模式下的CopyOnWriteArrayList 
        3.3.6数据共享通道：BlockingQueue 
        3.3.7随机数据结构：跳表（SkipList） 
    3.4参考资料 
第4章锁的优化及注意事项 
    4.1有助于提高“锁”性能的几点建议 
        4.1.1减小锁持有时间 
        4.1.2减小锁粒度 
        4.1.3读写分离锁来替换独占锁 
        4.1.4锁分离 
        4.1.5锁粗化 
    4.2Java虚拟机对锁优化所做的努力 
        4.2.1锁偏向 
        4.2.2轻量级锁 
        4.2.3自旋锁 
        4.2.4锁消除 
    4.3人手一支笔：ThreadLocal 
        4.3.1ThreadLocal的简单使用 
        4.3.2ThreadLocal的实现原理 
        4.3.3对性能有何帮助 
    4.4无锁 
        4.4.1与众不同的并发策略：比较交换（CAS） 
        4.4.2无锁的线程安全整数：AtomicInteger 
        4.4.3Java中的指针：Unsafe类 
        4.4.4无锁的对象引用：AtomicReference 
        4.4.5带有时间戳的对象引用：AtomicStampedReference 
        4.4.6数组也能无锁：AtomicIntegerArray 
        4.4.7让普通变量也享受原子操作：AtomicIntegerFieldUpdater 
        4.4.8挑战无锁算法：无锁的Vector实现 
        4.4.9让线程之间互相帮助：细看SynchronousQueue的实现 
    4.5有关死锁的问题 
    4.6参考文献 
第5章并行模式与算法 
    5.1探讨单例模式 
    5.2不变模式 
    5.3生产者—消费者模式 
    5.4高性能的生产者—消费者：无锁的实现 
        5.4.1无锁的缓存框架：Disruptor 
        5.4.2用Disruptor实现生产者—消费者案例 
        5.4.3提高消费者的响应时间：选择合适的策略 
        5.4.4CPUCache的优化：解决伪共享问题 
    5.5Future模式 
        5.5.1Future模式的主要角色 
        5.5.2Future模式的简单实现 
        5.5.3JDK中的Future模式 
    5.6并行流水线 
    5.7并行搜索 
    5.8并行排序 
        5.8.1分离数据相关性：奇偶交换排序 
        5.8.2改进的插入排序：希尔排序 
    5.9并行算法：矩阵乘法 
    5.10准备好了再通知我：网络NIO 
        5.10.1基于Socket的服务端的多线程模式 
        5.10.2使用NIO进行网络编程 
        5.10.3使用NIO来实现客户端 
    5.11读完了再通知我：AIO 
        5.11.1AIOEchoServer的实现 
        5.11.2AIOEcho客户端实现 
    5.12参考文献 
第6章Java8与并发 
    6.1Java8的函数式编程简介 
        6.1.1函数作为一等公民 
        6.1.2无副作用 
        6.1.3申明式的（Declarative） 
        6.1.4不变的对象 
        6.1.5易于并行 
        6.1.6更少的代码 
    6.2函数式编程基础 
        6.2.1FunctionalInterface注释 
        6.2.2接口默认方法 
        6.2.3lambda表达式 
        6.2.4方法引用 
    6.3一步一步走入函数式编程 
    6.4并行流与并行排序 
        6.4.1使用并行流过滤数据 
        6.4.2从集合得到并行流 
        6.4.3并行排序 
    6.5增强的Future：CompletableFuture 
        6.5.1完成了就通知我 
        6.5.2异步执行任务 
        6.5.3流式调用 
        6.5.4CompletableFuture中的异常处理 
        6.5.5组合多个CompletableFuture 
    6.6读写锁的改进：StampedLock 
        6.6.1StampedLock使用示例 
        6.6.2StampedLock的小陷阱 
        6.6.3有关StampedLock的实现思想 
    6.7原子类的增强 
        6.7.1更快的原子类：LongAdder 
        6.7.2LongAdder的功能增强版：LongAccumulator 
    6.8参考文献 
第7章使用Akka构建高并发程序 
    7.1新并发模型：Actor 
    7.2Akka之HelloWorld 
    7.3有关消息投递的一些说明 
    7.4Actor的生命周期 
    7.5监督策略 
    7.6选择Actor 
    7.7消息收件箱（Inbox） 
    7.8消息路由 
    7.9Actor的内置状态转换 
    7.10询问模式：Actor中的Future 
    7.11多个Actor同时修改数据：Agent 
    7.12像数据库一样操作内存数据：软件事务内存 
    7.13一个有趣的例子：并发粒子群的实现 
        7.13.1什么是粒子群算法 
        7.13.2粒子群算法的计算过程 
        7.13.3粒子群算法能做什么 
        7.13.4使用Akka实现粒子群 
    7.14参考文献 
第8章并行程序调试 
    8.1准备实验样本 
    8.2正式起航 
    8.3挂起整个虚拟机 
    8.4调试进入ArrayList内部
```